// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkProcessRegistrationDiffeoMorphicDemons.h"

#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractProcessFactory.h>

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

#include "itkImageRegistrationMethod.h"
#include "itkMattesMutualInformationImageToImageMetric.h"
#include "itkLinearInterpolateImageFunction.h"
#include "itkEuler3DTransform.h"
#include "itkCenteredTransformInitializer.h"

#include "itkImage.h"
#include "itkImageFileReader.h"
#include "itkImageFileWriter.h"
#include "itkMetaImageIO.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"
#include "itkExtractImageFilter.h"

#include "itkCommand.h"

#include "time.h"

#include <DiffeomorphicDemons/rpiDiffeomorphicDemons.hxx>
#include <rpiCommonTools.hxx>

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationDiffeoMorphicDemonsDiffeoMorphicDemonsPrivate
// /////////////////////////////////////////////////////////////////

class itkProcessRegistrationDiffeoMorphicDemonsPrivate
{
public:
    itkProcessRegistrationDiffeoMorphicDemons * proc;
    template <class PixelType>
            int update(void);
    template < typename TFixedImage, typename TMovingImage >
           bool write(const QString&);
    void * registrationMethod ;
    void deleteRegMethod(void);
    std::vector<unsigned int> iterations;
    unsigned char updateRule;
    unsigned char gradientType;
    float maximumUpdateStepLength;
    float updateFieldStandardDeviation;
    float displacementFieldStandardDeviation;
    bool useHistogramMatching;
};

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationDiffeoMorphicDemons
// /////////////////////////////////////////////////////////////////

itkProcessRegistrationDiffeoMorphicDemons::itkProcessRegistrationDiffeoMorphicDemons(void) : itkProcessRegistration(), d(new itkProcessRegistrationDiffeoMorphicDemonsPrivate)
{
    d->proc = this;
    d->registrationMethod = NULL ;
}

itkProcessRegistrationDiffeoMorphicDemons::~itkProcessRegistrationDiffeoMorphicDemons(void)
{
    d->proc = NULL;
    //d->deleteRegMethod();
    d->registrationMethod = NULL;
    delete d;
    d = NULL;
}

bool itkProcessRegistrationDiffeoMorphicDemons::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("itkProcessRegistrationDiffeoMorphicDemons",
              createitkProcessRegistrationDiffeoMorphicDemons);
}

QString itkProcessRegistrationDiffeoMorphicDemons::description(void) const
{
    return "itkProcessRegistrationDiffeoMorphicDemons";
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////


template <typename PixelType>
        int itkProcessRegistrationDiffeoMorphicDemonsPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
//    typedef itk::Image< long, 3 >  FixedImageType;
//    typedef itk::Image< long, 3 >  MovingImageType;
//    typedef float TransformScalarType;
    typedef rpi::DiffeomorphicDemons< FixedImageType, MovingImageType>//,
//                    TransformScalarType >
                        RegistrationType;
    RegistrationType * registration = new RegistrationType ();

    registrationMethod = registration;

    registration->SetFixedImage((const FixedImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const MovingImageType*) proc->movingImage().GetPointer());

    registration->SetNumberOfIterations(iterations);
    //registration->SetUpdateRule(updateRule);
    //registration->SetGradientType(gradientType);
    registration->SetMaximumUpdateStepLength(maximumUpdateStepLength);
    registration->SetUpdateFieldStandardDeviation(updateFieldStandardDeviation);
    registration->SetDisplacementFieldStandardDeviation(displacementFieldStandardDeviation);
    registration->SetUseHistogramMatching(useHistogramMatching);

    // Print method parameters
        qDebug() << "METHOD PARAMETERS";
//        qDebug() << "  Max number of iterations   : " << registration->GetNumberOfIterations();
//        std::cout << "  Iterations                            : " << rpi::VectorToString<unsigned int>( registration->GetNumberOfIterations() ) << std::endl;
            std::cout << "  Update rule                           : " << registration->GetUpdateRule()                                              << std::endl;
            std::cout << "  Maximum step length                   : " << registration->GetMaximumUpdateStepLength()              << " (voxel unit)" << std::endl;
            std::cout << "  Gradient type                         : " << registration->GetGradientType()                                            << std::endl;
            std::cout << "  Update field standard deviation       : " << registration->GetUpdateFieldStandardDeviation()         << " (voxel unit)" << std::endl;
            std::cout << "  Displacement field standard deviation : " << registration->GetDisplacementFieldStandardDeviation()   << " (voxel unit)" << std::endl;
            std::cout << "  Use histogram matching?               : " << rpi::BooleanToString( registration->GetUseHistogramMatching() )            << std::endl << std::endl;



    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;

    typedef itk::ResampleImageFilter< MovingImageType,MovingImageType >    ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(registration->GetTransformation());
    resampler->SetInput((const MovingImageType*)proc->movingImage().GetPointer());
    //typename FixedImageType::Pointer fixedImage = fixedImage;
    resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );

  // typedef  float  OutputPixelType;
  // typedef itk::Image< OutputPixelType, Dimension > OutputImageType;
  // typedef itk::CastImageFilter< FixedImageType, OutputImageType > CastFilterType;
  // typedef itk::ImageFileWriter< OutputImageType >  WriterType;

  // WriterType::Pointer      writer =  WriterType::New();
  // CastFilterType::Pointer  caster =  CastFilterType::New();
  // const char* outputImageFilename = "/Users/jwintz/Desktop/output.nhdr";

  // writer->SetFileName( outputImageFilename );
  // caster->SetInput( resampler->GetOutput() );
  // writer->SetInput( caster->GetOutput()   );
  // writer->Update();

  // std::ofstream outfile;
  // const char* transformationMatrixFilename = "/Users/jwintz/Desktop/transfoMat.txt";
  // outfile.open(transformationMatrixFilename, std::ofstream::out);
  // outfile << matrix[0][0] << " " <<  matrix[0][1] << " " <<  matrix[0][2]
  //       		 << " " << offset[0]d->write< FixedImageType,MovingImageType >  (file);
  //       		 << std::endl
  //       		 << matrix[1][0] << " " <<  matrix[1][1] << " " <<  matrix[1][2]
  //       		 << " " << offset[1]
  //       		 << std::endl
  //       		 << matrix[2][0] << " " <<  matrix[2][1] << " " <<  matrix[2][2]
  //       		 << " " << offset[2]
  //       		 << std::endl
  //       		 << "0 0 0 1"
  //       		 << std::endl;
  // outfile.close();

    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << e.GetDescription();
        return 1;
    }

    itk::ImageBase<3>::Pointer result = resampler->GetOutput();
    result->DisconnectPipeline();


    if (proc->output())
      proc->output()->setData (result);
    return 0;
}

int itkProcessRegistrationDiffeoMorphicDemons::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImage().IsNull())
        return 1;
    switch (imgType){
//    case itkProcessRegistration::UCHAR:
//        return d->update<unsigned char>();
//        break;
    case itkProcessRegistration::CHAR:
        return d->update<char>();
        break;
//    case itkProcessRegistration::USHORT:
//        return d->update<unsigned short>();
        break;
    case itkProcessRegistration::SHORT:
        return d->update<short>();
        break;
//    case itkProcessRegistration::UINT:
//       return d->update<unsigned int>();
//       break;
    case itkProcessRegistration::INT:
        return d->update<int>();
        break;
//    case itkProcessRegistration::ULONG:
//       return d->update<unsigned long>();
//       break;
//    case itkProcessRegistration::LONG:
//        return d->update<long>();
//        break;
    case itkProcessRegistration::DOUBLE:
        return d->update<double>();
        break;
    default:
        return d->update<float>();
        break;
    }
}



template <typename FixedPixelType,typename MovingPixelType>
bool itkProcessRegistrationDiffeoMorphicDemonsPrivate::write(const QString&)
{
//    typename rpi::DiffeoMorphicDemons<FixedImageType,MovingImageType> * registration =
//            (typename rpi::DiffeoMorphicDemons<FixedImageType,MovingImageType> *)registrationMethod;

    return true;
}



bool itkProcessRegistrationDiffeoMorphicDemons::writeTransform(const QString& file)
{
    return false;
}

//bool itkProcessRegistrationDiffeoMorphicDemons::writeTransform(const QString& file)
//{
//    return false;
//}

void itkProcessRegistrationDiffeoMorphicDemons::setNumberOfIterations(std::vector<unsigned int> iterations)
{
    d->iterations = iterations;
}



// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createitkProcessRegistrationDiffeoMorphicDemons(void)
{
    return new itkProcessRegistrationDiffeoMorphicDemons;
}

void itkProcessRegistrationDiffeoMorphicDemons::setUpdateRule(unsigned char updateRule)
{
    d->updateRule = updateRule;
}

void itkProcessRegistrationDiffeoMorphicDemons::setGradientType(unsigned char gradientType)
{
    d->gradientType = gradientType;
}

void itkProcessRegistrationDiffeoMorphicDemons::setMaximumUpdateLength(float maximumUpdateStepLength)
{
    d->maximumUpdateStepLength = maximumUpdateStepLength;
}

void itkProcessRegistrationDiffeoMorphicDemons::setUpdateFieldStandardDeviation(float updateFieldStandardDeviation)
{
    d->updateFieldStandardDeviation = updateFieldStandardDeviation;
}

void itkProcessRegistrationDiffeoMorphicDemons::setDisplacementFieldStandardDeviation(float displacementFieldStandardDeviation)
{
    d->displacementFieldStandardDeviation = displacementFieldStandardDeviation;
}

void itkProcessRegistrationDiffeoMorphicDemons::setUseHistogramMatching(bool useHistogramMatching)
{
    d->useHistogramMatching = useHistogramMatching;
}
