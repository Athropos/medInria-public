// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "medItk.h"

#include "itkDCMTKDataImageReader.h"

#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractDataFactory.h>

#include <itkImageFileReader.h>
#include <itkDCMTKImageIO.h>



namespace itk
{
  
  class SliceReadCommand : public Command
  {
    
  public:
    typedef SliceReadCommand               Self;
    typedef Command                        Superclass;
    typedef itk::SmartPointer<Self>        Pointer;
    typedef itk::SmartPointer<const Self>  ConstPointer;
    
    itkTypeMacro( SliceReadCommand, Command );
    itkNewMacro (Self);
    
    void Execute(Object *caller, const EventObject &event);
    void Execute(const Object *caller, const EventObject &event);

    void SetDCMTKDataImageReader (itkDCMTKDataImageReader* reader)
    { m_Reader = reader; }
    
  protected:
    SliceReadCommand(){ m_Reader = 0; };
    virtual ~SliceReadCommand(){};

  private:
    itkDCMTKDataImageReader* m_Reader;
    
  };
  
  
  void SliceReadCommand::Execute (Object *caller, const EventObject &event)
  {
    DCMTKImageIO *po = dynamic_cast<DCMTKImageIO *>(caller);
    if (! po)
      return;
    
    if( typeid(event) == typeid ( itk::SliceReadEvent )  )
    {
      /*
	if (m_Reader)
	m_Reader->progressUpdated ( 0 );
      */
    }
  }
  
  
  void SliceReadCommand::Execute (const Object *caller, const EventObject &event)
  {
    DCMTKImageIO *po = dynamic_cast<DCMTKImageIO *>(const_cast<Object *>(caller) );
    if (! po)
      return;
    
    if( typeid(event) == typeid ( SliceReadEvent  )  )
    {
      /*
	if (m_Reader)
	m_Reader->progressUpdated ( 0 );
      */
    }
  }
  
}




// /////////////////////////////////////////////////////////////////
// itkDCMTKDataImageReaderPrivate
// /////////////////////////////////////////////////////////////////

class itkDCMTKDataImageReaderPrivate
{
public:
    itkDCMTKDataImageReaderPrivate();
    ~itkDCMTKDataImageReaderPrivate(){};
  
    itk::DCMTKImageIO::Pointer io;
};


itkDCMTKDataImageReaderPrivate::itkDCMTKDataImageReaderPrivate()
{
    io = itk::DCMTKImageIO::New();
}

// /////////////////////////////////////////////////////////////////
// itkDCMTKDataImageReader
// /////////////////////////////////////////////////////////////////


itkDCMTKDataImageReader::itkDCMTKDataImageReader(void) : dtkAbstractDataReader(), d(new itkDCMTKDataImageReaderPrivate)
{

}


itkDCMTKDataImageReader::~itkDCMTKDataImageReader(void)
{

}


bool itkDCMTKDataImageReader::registered(void)
{
    return dtkAbstractDataFactory::instance()->registerDataReaderType("itkDCMTKDataImageReader", QStringList() << "itkDataImageDouble3"
								      << "itkDataImageFloat3"
								      << "itkDataImageULong3"
								      << "itkDataImageLong3"
								      << "itkDataImageUInt3"
								      << "itkDataImageInt3"
								      << "itkDataImageUShort3"
								      << "itkDataImageShort3"
								      << "itkDataImageUChar3"
								      << "itkDataImageChar3",
								      createItkDCMTKDataImageReader);
}


QStringList itkDCMTKDataImageReader::handled(void) const
{
    return QStringList() << "itkDataImageDouble3"
			 << "itkDataImageFloat3"
			 << "itkDataImageULong3"
			 << "itkDataImageLong3"
			 << "itkDataImageUInt3"
			 << "itkDataImageInt3"
			 << "itkDataImageUShort3"
			 << "itkDataImageShort3"
			 << "itkDataImageUChar3"
			 << "itkDataImageChar3";
}


QString itkDCMTKDataImageReader::description(void) const
{
    return "itkDCMTKDataImageReader";
}


bool itkDCMTKDataImageReader::canRead (QString path)
{
    return d->io->CanReadFile ( path.toAscii().constData() );
}


bool itkDCMTKDataImageReader::canRead (QStringList paths)
{
  for (int i=0; i<paths.size(); i++)
    if (!d->io->CanReadFile ( paths[i].toAscii().constData() ))
      return false;
  return true;
}


void itkDCMTKDataImageReader::readInformation (QString path)
{
  QStringList paths;
  paths << path;
  readInformation ( paths );  
}


void itkDCMTKDataImageReader::readInformation (QStringList paths)
{
    if (paths.size()==0)
      return;

    std::vector< std::string > filenames;
    for (int i=0; i<paths.size(); i++)
      filenames.push_back ( paths[i].toAscii().constData() );

    d->io->SetFileNames ( filenames );
    try {
      d->io->ReadImageInformation();
    }
    catch (itk::ExceptionObject &e) {
      std::cerr << e;
      return;
    }
    

    dtkAbstractData* dtkdata = this->data();

    
    if (!dtkdata) {
      switch (d->io->GetComponentType()) {
	  case itk::ImageIOBase::UCHAR:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageUChar3");
	    if (dtkdata)
	      this->setData ( dtkdata );
	    break;
	    
	  case itk::ImageIOBase::CHAR:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageChar3");
	    if (dtkdata)
	      this->setData ( dtkdata );
	    break;

	  case itk::ImageIOBase::USHORT:
	    {
	      dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageUShort3");
	      if (dtkdata) 
		this->setData ( dtkdata );
	      break;
	    }
	    
	  case itk::ImageIOBase::SHORT:
	    {
	      dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageShort3");
	      if (dtkdata)
		this->setData ( dtkdata );
	    }
	    break;

	  case itk::ImageIOBase::UINT:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageUInt3");
	    if (dtkdata)
	      this->setData ( dtkdata );
	    break;

	  case itk::ImageIOBase::INT:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageInt3");
	    if (dtkdata)
	      this->setData ( dtkdata );
	  break;

	  case itk::ImageIOBase::ULONG:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageULong3");
	    if (dtkdata)
	      this->setData ( dtkdata );
	  break;

	  case itk::ImageIOBase::LONG:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageLong3");
	    if (dtkdata)
	    this->setData ( dtkdata );
	  break;

	  case itk::ImageIOBase::FLOAT:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageFloat3");
	    if (dtkdata)
	    this->setData ( dtkdata );
	  break;

	  case itk::ImageIOBase::DOUBLE:
	    dtkdata = dtkAbstractDataFactory::instance()->create ("itkDataImageDouble3");
	    if (dtkdata)
	      this->setData ( dtkdata );
	    break;

	  default:
	    {
	      std::cerr << "Unrecognized component type" << std::endl;
	      return;
	    }
      }
    }

    if (dtkdata) {

      QStringList patientName;
      QStringList studyName;
      QStringList seriesName;
      
      patientName << d->io->GetPatientName().c_str();
      studyName << d->io->GetStudyDescription().c_str();
      seriesName << d->io->GetSeriesDescription().c_str();

      
      if (!dtkdata->hasMetaData ( tr ("PatientName") ))
	dtkdata->addMetaData ( "PatientName", patientName );
      else
	dtkdata->setMetaData ( "PatientName", patientName );

      if (!dtkdata->hasMetaData ( tr ("StudyDescription") ))
	dtkdata->addMetaData ( "StudyDescription", studyName );
      else
	dtkdata->setMetaData ( "StudyDescription", studyName );

      if (!dtkdata->hasMetaData ( tr ("SeriesDescription") ))
	dtkdata->addMetaData ( "SeriesDescription", seriesName );
      else
	dtkdata->setMetaData ( "SeriesDescription", seriesName );
	
    }
}


bool itkDCMTKDataImageReader::read (QString path)
{
  QStringList paths;
  paths << path;
  return read ( paths );
}


bool itkDCMTKDataImageReader::read (QStringList paths)
{
  if (paths.size()==0)
    return false;

  readInformation ( paths );
  
  if (d->io->GetNumberOfDimensions() != 3) {
    std::cerr << "Only 3D images are supported for now (required: " << d->io->GetNumberOfDimensions() << ")" << std::endl;
    return false;
  }

  itk::SliceReadCommand::Pointer command = itk::SliceReadCommand::New();
  command->SetDCMTKDataImageReader ( this );
  d->io->AddObserver ( itk::SliceReadEvent(), command);
  
  switch (d->io->GetComponentType()) {
    
      case itk::ImageIOBase::UCHAR:
	{
	  itk::ImageFileReader< itk::Image<unsigned char, 3> >::Pointer ucharReader = itk::ImageFileReader< itk::Image<unsigned char, 3> >::New();
	  ucharReader->SetImageIO ( d->io );
	  ucharReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( ucharReader->GetOutput() );
	  try {
	    ucharReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
      case itk::ImageIOBase::CHAR:
	{
	  itk::ImageFileReader< itk::Image<char, 3> >::Pointer charReader = itk::ImageFileReader< itk::Image<char, 3> >::New();
	  charReader->SetImageIO ( d->io );
	  charReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( charReader->GetOutput() );
	  try {
	    charReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
      case itk::ImageIOBase::USHORT:
	{
	  itk::ImageFileReader< itk::Image<unsigned short, 3> >::Pointer ushortReader = itk::ImageFileReader< itk::Image<unsigned short, 3> >::New();
	  ushortReader->SetImageIO ( d->io );
	  ushortReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( ushortReader->GetOutput() );
	  try {
	    ushortReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
	case itk::ImageIOBase::SHORT:
	{
	  itk::ImageFileReader< itk::Image<short, 3> >::Pointer shortReader = itk::ImageFileReader< itk::Image<short, 3> >::New();
	  shortReader->SetImageIO ( d->io );
	  shortReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( shortReader->GetOutput() );
	  try {
	    shortReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
	case itk::ImageIOBase::UINT:
	{
	  itk::ImageFileReader< itk::Image<unsigned int, 3> >::Pointer uintReader = itk::ImageFileReader< itk::Image<unsigned int, 3> >::New();
	  uintReader->SetImageIO ( d->io );
	  uintReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( uintReader->GetOutput() );
	  try {
	    uintReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
	case itk::ImageIOBase::INT:
	{
	  itk::ImageFileReader< itk::Image<int, 3> >::Pointer intReader = itk::ImageFileReader< itk::Image<int, 3> >::New();
	  intReader->SetImageIO ( d->io );
	  intReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( intReader->GetOutput() );
	  try {
	    intReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
	case itk::ImageIOBase::ULONG:
	{
	  itk::ImageFileReader< itk::Image<unsigned long, 3> >::Pointer ulongReader = itk::ImageFileReader< itk::Image<unsigned long, 3> >::New();
	  ulongReader->SetImageIO ( d->io );
	  ulongReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( ulongReader->GetOutput() );
	  try {
	    ulongReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
	case itk::ImageIOBase::LONG:
	{
	  itk::ImageFileReader< itk::Image<long, 3> >::Pointer longReader = itk::ImageFileReader< itk::Image<long, 3> >::New();
	  longReader->SetImageIO ( d->io );
	  longReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( longReader->GetOutput() );
	  try {
	    longReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
	case itk::ImageIOBase::FLOAT:
	{
	  itk::ImageFileReader< itk::Image<float, 3> >::Pointer floatReader = itk::ImageFileReader< itk::Image<float, 3> >::New();
	  floatReader->SetImageIO ( d->io );
	  floatReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( floatReader->GetOutput() );
	  try {
	    floatReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
	case itk::ImageIOBase::DOUBLE:
	{
	  itk::ImageFileReader< itk::Image<double, 3> >::Pointer doubleReader = itk::ImageFileReader< itk::Image<double, 3> >::New();
	  doubleReader->SetImageIO ( d->io );
	  doubleReader->SetFileName ( paths[0].toAscii().constData() );
	  if( dtkAbstractData* dtkdata = this->data() )
	    dtkdata->setData ( doubleReader->GetOutput() );
	  try {
	    doubleReader->Update();
	  }
	  catch (itk::ExceptionObject &e) {
	    std::cerr << e;
	    return false;
	  }
	  break;
	}
      default:
	{
	  std::cerr << "Unrecognized component type" << std::endl;
	  return false;
	}
  }

  d->io->RemoveAllObservers ();
  
  return true;

}

// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractDataReader *createItkDCMTKDataImageReader(void)
{
    return new itkDCMTKDataImageReader;
}

