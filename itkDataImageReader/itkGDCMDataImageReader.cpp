// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkGDCMDataImageReader.h"

#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractDataFactory.h>

#include <itkImageFileReader.h>
#include <itkRGBPixel.h>
#include <itkGDCMImageIO.h>
#include <itkMetaDataDictionary.h>
#include <itkObjectFactoryBase.h>
#include "itkDataImageReaderCommand.h"

#include "gdcmReader.h"
#include "gdcmDirectionCosines.h"
#include "gdcmStringFilter.h"


// /////////////////////////////////////////////////////////////////
// itkGDCMDataImageReaderPrivate
// /////////////////////////////////////////////////////////////////

class itkGDCMDataImageReaderPrivate
{
public:
  itkGDCMDataImageReaderPrivate();
  ~itkGDCMDataImageReaderPrivate(){};
  
  itk::GDCMImageIO::Pointer io;
};


itkGDCMDataImageReaderPrivate::itkGDCMDataImageReaderPrivate()
{
  io = itk::GDCMImageIO::New();
}

// /////////////////////////////////////////////////////////////////
// itkGDCMDataImageReader
// /////////////////////////////////////////////////////////////////


itkGDCMDataImageReader::itkGDCMDataImageReader(void) : dtkAbstractDataReader(), d(new itkGDCMDataImageReaderPrivate)
{
  
}


itkGDCMDataImageReader::~itkGDCMDataImageReader(void)
{
  delete d;
  d = 0;
}


bool itkGDCMDataImageReader::registered(void)
{
  return dtkAbstractDataFactory::instance()->registerDataReaderType("itkGDCMDataImageReader",
								    QStringList()
								    << "itkDataImageDouble3"
								    << "itkDataImageFloat3"
								    << "itkDataImageULong3"
								    << "itkDataImageLong3"
								    << "itkDataImageUInt3"
								    << "itkDataImageInt3"
								    << "itkDataImageUShort3"
								    << "itkDataImageUShort4"
								    << "itkDataImageShort3"
								    << "itkDataImageShort4"
								    << "itkDataImageUChar3"
								    << "itkDataImageChar3"
								    << "itkDataImageRGB3",
								    createItkGDCMDataImageReader);
}


QStringList itkGDCMDataImageReader::handled(void) const
{
  return QStringList() << "itkDataImageDouble3"
		       << "itkDataImageFloat3"
		       << "itkDataImageULong3"
		       << "itkDataImageLong3"
		       << "itkDataImageUInt3"
		       << "itkDataImageInt3"
		       << "itkDataImageUShort3"
		       << "itkDataImageUShort4"
		       << "itkDataImageShort3"
		       << "itkDataImageShort4"
		       << "itkDataImageUChar3"
		       << "itkDataImageChar3"
		       << "itkDataImageRGB3";
}


QString itkGDCMDataImageReader::description(void) const
{
  return "itkGDCMDataImageReader";
}


bool itkGDCMDataImageReader::canRead (QString path)
{
  return d->io->CanReadFile ( path.toAscii().constData() );
}


bool itkGDCMDataImageReader::canRead (QStringList paths)
{
  for (int i=0; i<paths.size(); i++)
    if (!d->io->CanReadFile ( paths[i].toAscii().constData() ))
      return false;
  return true;
}


void itkGDCMDataImageReader::readInformation (QString path)
{
  QStringList paths;
  paths << path;
  readInformation ( paths );  
}


void itkGDCMDataImageReader::readInformation (QStringList paths)
{
  if (paths.size()==0)
    return;

  FileList filenames;
  for (int i=0; i<paths.size(); i++)
    filenames.push_back ( paths[i].toAscii().constData() );




  FileListMapType map = this->Sort (filenames);


  
  std::cout<<"building volume containing "<<map.size()<<" subvolumes..."<<std::flush;

  if (!map.size())
  {
    qDebug() << "No image can be build from file list" << std::endl;
    return;
  }

  if (map.size() > 1)
  {
    qDebug() << "cannot build 4D volumes yet" << std::endl;
    return;
  }
  
  std::string firstfilename = (*map.begin()).second[0];
  
  d->io->SetFileName ( firstfilename.c_str() );
  try
  {
    d->io->ReadImageInformation();
  }
  catch (itk::ExceptionObject &e)
  {
    qDebug() << e.GetDescription();
    return;
  }

  dtkAbstractData* dtkdata = this->data();    

  if (!dtkdata)
  {    
    unsigned int imagedimension = 3;
    
    if (map.size() > 1)
      imagedimension = 4;
    
    std::ostringstream imagetypestring;
    imagetypestring << "itkDataImage";
  
    if (d->io->GetPixelType() != itk::ImageIOBase::SCALAR )
    {
      qDebug() << "Unsupported pixel type";
      return;
    }
    else
    {
      switch (d->io->GetComponentType())
      {
	  case itk::ImageIOBase::UCHAR:
	    imagetypestring << "UChar";
	    break;
	  case itk::ImageIOBase::CHAR:
	    imagetypestring << "Char";
	    break;
	  case itk::ImageIOBase::USHORT:
	    imagetypestring << "UShort";
	    break;
	  case itk::ImageIOBase::SHORT:
	    imagetypestring << "Short";
	    break;
	  case itk::ImageIOBase::UINT:
	    imagetypestring << "UInt";
	    break;
	  case itk::ImageIOBase::INT:
	    imagetypestring << "Int";
	    break;
	  case itk::ImageIOBase::ULONG:
	    imagetypestring << "ULong";
	    break;
	  case itk::ImageIOBase::LONG:
	    imagetypestring << "Long";
	    break;
	  case itk::ImageIOBase::FLOAT:
	    imagetypestring << "Float";
	    break;
	  case itk::ImageIOBase::DOUBLE:
	    imagetypestring << "Double";
	    break;
	  default:
	    qDebug() << "Unrecognized component type: " << d->io->GetComponentType() << std::endl;
	    return;
      }

      imagetypestring << imagedimension;

      dtkdata = dtkAbstractDataFactory::instance()->create (imagetypestring.str().c_str());
      if (dtkdata)
	this->setData ( dtkdata );
    }
  }

  if (dtkdata) {

    QStringList patientName;
    QStringList studyName;
    QStringList seriesName;
    QStringList studyId;
    QStringList seriesId;
    QStringList orientation;
    QStringList seriesNumber;
    QStringList sequenceName;
    QStringList sliceThickness;
    QStringList rows;
    QStringList columns;
    QStringList filePaths;
	
    patientName    << this->GetTagValue(firstfilename.c_str(), gdcm::Tag(0x0010,0x0010));
    studyName      << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0008,0x0130));
    seriesName     << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0008,0x103e));
    studyId        << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0020,0x000d));
    seriesId       << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0020,0x000e));
    orientation    << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0020,0x0037));
    seriesNumber   << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0020,0x0011)); 
    sequenceName   << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0018,0x0024));
    sliceThickness << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0018,0x0050));
    rows           << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0028,0x0010));
    columns        << this->m_Scanner.GetValue(firstfilename.c_str(), gdcm::Tag(0x0028,0x0011));

    FileList orderedfilelist = this->unfoldMap (map);
    
    for (unsigned int i=0; i<orderedfilelist.size(); i++ )
      filePaths << orderedfilelist[i].c_str();
      
    if (!dtkdata->hasMetaData ( tr ("PatientName") ))
      dtkdata->addMetaData ( "PatientName", patientName );
    else
      dtkdata->setMetaData ( "PatientName", patientName );

    if (!dtkdata->hasMetaData ( tr ("StudyDescription") ))
      dtkdata->addMetaData ( "StudyDescription", studyName );
    else
      dtkdata->setMetaData ( "StudyDescription", studyName );

    if (!dtkdata->hasMetaData ( tr ("SeriesDescription") ))
      dtkdata->addMetaData ( "SeriesDescription", seriesName );
    else
      dtkdata->setMetaData ( "SeriesDescription", seriesName );

    dtkdata->setMetaData("StudyID", studyId);
    dtkdata->setMetaData("SeriesID", seriesId);
    dtkdata->setMetaData("Orientation", orientation);
    dtkdata->setMetaData("SeriesNumber", seriesNumber);
    dtkdata->setMetaData("SequenceName", sequenceName);
    dtkdata->setMetaData("SliceThickness", sliceThickness);
    dtkdata->setMetaData("Rows", rows);
    dtkdata->setMetaData("Columns", columns);

    dtkdata->addMetaData ("FilePaths", orderedfilelist);
	
  }
}


bool itkGDCMDataImageReader::read (QString path)
{
  QStringList paths;
  paths << path;
  return read ( paths );
}


bool itkGDCMDataImageReader::read (QStringList paths)
{
  if (paths.size()==0)
    return false;

  this->readInformation ( paths );
  
  itk::DataImageReaderCommand::Pointer command = itk::DataImageReaderCommand::New();
  command->SetGDCMDataImageReader ( this );
  d->io->AddObserver ( itk::ProgressEvent(), command);

  if (dtkAbstractData *dtkdata = this->data() )
  {
    Qstringlist qfilelist = dtkdata->metaDataValues ("FilePaths");
    FileList filelist;
    for (unsigned int i=0; i<qfilelist.size(); i++)
      filelist[i] = qfilelist[i];
    
    itk::ProcessObject::Pointer process;
    
    if      (dtkdata->description() == "itkDataImageUChar3")
      this->CreateReader< unsigned char, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageChar3")
      this->CreateReader<          char, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageUShort3")
      this->CreateReader<unsigned short, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageShort3")
      this->CreateReader<         short, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageUInt3")
      this->CreateReader<  unsigned int, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageInt3")
      this->CreateReader<           int, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageULong3")
      this->CreateReader< unsigned long, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageLong3")
      this->CreateReader<          long, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageFloat3")
      this->CreateReader<         float, 3>(filelist, d->io, process);
    else if (dtkdata->description() == "itkDataImageDouble3")
      this->CreateReader<        double, 3>(filelist, d->io, process);
    else
    {
      qDebug() << "Unrecognized dtkdata description : " << dtkdata->description();
      return false;
    }

    dtkdata->setData ( process->GetOutput() );

    try
    {
      process->Update();
    }
    catch (itk::ExceptionObject &e)
    {
      qDebug() << e.GetDescription();
      return false;
    }    
    
    // copy over the dicom dictionary into metadata
    typedef itk::GDCMImageIO::MetaDataVectorStringType MetaDataVectorStringType;
    typedef itk::GDCMImageIO::StringVectorType         StringVectorType;
    
    const itk::MetaDataDictionary& dictionary = d->io->GetMetaDataDictionary();
    itk::MetaDataDictionary::ConstIterator it = dictionary.Begin();
    while(it!=dictionary.End())
    {
      if( MetaDataVectorStringType* metaData = dynamic_cast<MetaDataVectorStringType*>( it->second.GetPointer() ) )
      {
	const StringVectorType &values = metaData->GetMetaDataObjectValue();
	for (unsigned int i=0; i<values.size(); i++)
	  dtkdata->addMetaData( it->first.c_str(), values[i].c_str());
      }
      ++it;
    }
  }
  
  d->io->RemoveAllObservers ();
  
  return true;

}

itkGDCMDataImageReader::FileListMapType itkGDCMDataImageReader::Sort (FileList list)
{  
  this->m_Scanner->Scan (list);
  FileListMapType ret;
  return ret;
}

itkGDCMDataImageReader::FileList itkGDCMDataImageReader::UnfoldMap (FileListMapType map)
{  
  FileList ret;
  return ret;
}



// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractDataReader *createItkGDCMDataImageReader(void)
{
  return new itkGDCMDataImageReader;
}

