// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkProcessiLogDemonRegistration.h"

#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractProcessFactory.h>

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

#include "itkImageRegistrationMethod.h"

#include "itkImage.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"

#include "time.h"


#include <rpiCommonTools.hxx>
// /////////////////////////////////////////////////////////////////
// itkProcessiLogDemonRegistrationPrivate
// /////////////////////////////////////////////////////////////////

class itkProcessiLogDemonRegistrationPrivate
{
public:
    

    itkProcessiLogDemonRegistration *proc;
    template <class PixelType>
        int update(void);
    template < typename TFixedImage, typename TMovingImage >
         bool write(const QString&);
    void * registrationMethod ;

    std::vector<unsigned int> iterations;
    int           minIterations;
    float         maximumUpdateStepLength;
    unsigned int  gradientType;
    float         upFieldSigma;
    unsigned int  upFieldInc;
    float         upFieldKappa;
    float         velFieldSigma;
    unsigned int  velFieldInc;
    float         velFieldKappa;
    bool          useHistogramMatching;
    unsigned int  BCHExpansion;
    std::vector<float>   stop;
    float         spatialDerivativeSigma;
    unsigned int  stepSize;
    float         DTIStandardDeviation;
    unsigned int  noiseEstimatorType;
    float         noiseEstimatorSigma;
    bool          noiseEstimatorLM;
    float         noiseEstimatorEpsilon;                  


};

// /////////////////////////////////////////////////////////////////
// itkProcessiLogDemonRegistration
// /////////////////////////////////////////////////////////////////

itkProcessiLogDemonRegistration::itkProcessiLogDemonRegistration(void) : itkProcessRegistration(), d(new itkProcessiLogDemonRegistrationPrivate)
{
    d->proc = this;
    d->registrationMethod = NULL;
    d->minIterations = -1;
    d->maximumUpdateStepLength = 2.0;
    d->gradientType = 0;
    d->upFieldSigma = 0.0;
    d->upFieldInc = 0;
    d->upFieldKappa = 0.0;
    d->velFieldSigma = 1.5;
    d->velFieldInc = 1;
    d->velFieldKappa = 0.0;
    d->useHistogramMatching = false;
    d->BCHExpansion = 2;
    d->spatialDerivativeSigma = 0.5;
    d->stepSize = 5;
    d->DTIStandardDeviation = 0.0;
    d->noiseEstimatorType =0;
    d->noiseEstimatorSigma = 5.0;
    d->noiseEstimatorLM = false;
    d->noiseEstimatorEpsilon = 0.0;	
}

itkProcessiLogDemonRegistration::~itkProcessiLogDemonRegistration(void)
{
    d->proc = NULL;
    d->registrationMethod = NULL;
    delete d;
    d = NULL;
}

bool itkProcessiLogDemonRegistration::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("itkProcessiLogDemonRegistration", createItkProcessiLogDemonRegistration);
}

QString itkProcessiLogDemonRegistration::description(void) const
{
    return "itkProcessiLogDemonRegistration";
}

template <typename PixelType>
int itkProcessiLogDemonRegistrationPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
    
    typedef itk::Image< float, 3 > RegImageType;

    typedef float TransformScalarType;

    typedef unsigned char MaskPixelType;

    typedef itk::Image<MaskPixelType, 3> MaskType;

    typedef rpi::IncompressibleLogDemons< RegImageType, RegImageType, TransformScalarType, MaskPixelType > RegistrationMethod;

    //////

    typedef itk::Transform<TransformScalarType, 3, 3> LinearTransformType;

    typedef itk::StationaryVelocityFieldTransform< TransformScalarType, 3 > StationaryVelocityFieldTransformType;

    typedef itk::DisplacementFieldTransform< TransformScalarType, 3 > DisplacementFieldTransformType;

    //////

    RegistrationType * registration = new RegistrationType;

    registrationMethod = registration;

    typedef itk::CastImageFilter< FixedImageType, RegImageType > CastFilterType;
    typename CastFilterType::Pointer  caster =  CastFilterType::New();
    caster->SetInput((const FixedImageType*)proc->fixedImage().GetPointer());
    caster->Update();
    registration->SetFixedImage(caster->GetOutput());

    typedef itk::CastImageFilter< MovingImageType, RegImageType > CastFilterMovingType;
    typename CastFilterType::Pointer  casterMov =  CastFilterType::New();
    casterMov->SetInput((const MovingImageType*)proc->movingImage().GetPointer());
    casterMov->Update();
    registration->SetMovingImage(casterMov->GetOutput());
    

    registration->SetNumberOfIterations(iterations);
    registration->SetMinimumNumberOfIterations(minIterations);
    registration->SetMaximumUpdateStepLength(maximumUpdateStepLength);
    registration->SetUpdateFieldStandardDeviation(upFieldSigma);
    registration->SetUpdateFieldKappa(upFieldKappa);
    registration->SetStationaryVelocityFieldStandardDeviation(velFieldSigma);
    registration->SetStationaryVelocityFieldKappa(velFieldKappa);
    registration->SetUseHistogramMatching(useHistogramMatching);
    registration->SetNumberOfTermsBCHExpansion(BCHExpansion);
    registration->SetStopThreshold(stop);
    registration->SetSpatialDerivativeStandardDeviation(spatialDerivativeSigma);
    registration->SetStepSize(stepSize);
    registration->SetDTIStandardDeviation(DTIStandardDeviation);
    registration->SetNoiseEstimatorStandardDeviation(noiseEstimatorSigma);
    registration->SetNoiseEstimatorLM(noiseEstimatorLM);
    registration->SetNoiseEstimatorEpsilon(noiseEstimatorEpsilon);


    switch( gradientType )
    {
    case 0:
        registration->SetGradientType( RegistrationMethod::GRADIENT_SYMMETRIZED );         break;
    case 1:
        registration->SetGradientType( RegistrationMethod::GRADIENT_FIXED_IMAGE );         break;
    case 2:
        registration->SetGradientType( RegistrationMethod::GRADIENT_WARPED_MOVING_IMAGE ); break;
    case 3:
        registration->SetGradientType( RegistrationMethod::GRADIENT_MAPPED_MOVING_IMAGE ); break;
    default:
        throw std::runtime_error( "Gradient type must fit in the range [0,3]." );
    }


    switch( upFieldInc )
    {
    case 0:
        registration->SetUpdateFieldIncompressibility( RegistrationMethod::UP_INCOMPRESSIBILITY_DISABLED );
        break;
    case 1:
        registration->SetUpdateFieldIncompressibility( RegistrationMethod::UP_INCOMPRESSIBILITY_L2_NORM_PROJECTION );
        break;
    case 2:
        registration->SetUpdateFieldIncompressibility( RegistrationMethod::UP_INCOMPRESSIBILITY_HESSIAN_NORM_PROJECTION );
        break;
    case 3:
        registration->SetUpdateFieldIncompressibility( RegistrationMethod::UP_INCOMPRESSIBILITY_ALTERNATE_PROJECTION );
        break;
    default:
        throw std::runtime_error( "Incompressibility type of the update field must fit in the range [0,3]." );
    }

    switch( velFieldInc )
    {
    case 0:
        registration->SetStationaryVelocityFieldIncompressibility( RegistrationMethod::VEL_INCOMPRESSIBILITY_DISABLED );
        break;
    case 1:
        registration->SetStationaryVelocityFieldIncompressibility( RegistrationMethod::VEL_INCOMPRESSIBILITY_ENABLED );
        break;
    default:
        throw std::runtime_error( "Incompressibility type of the stationary velocity field must fit in the range [0,1]." );
    }

    switch( noiseEstimatorType )
    {
    case 0:
        registration->SetNoiseEstimatorType( RegistrationMethod::NOISE_ESTIMATOR_LOCAL );
        break;
    case 1:
        registration->SetNoiseEstimatorType( RegistrationMethod::NOISE_ESTIMATOR_REGIONAL );
        break;
    case 2:
        registration->SetNoiseEstimatorType( RegistrationMethod::NOISE_ESTIMATOR_GLOBAL );
        break;
    default:
        throw std::runtime_error( "Noise estimator type must fit in the range [0,2]." );
    }

     // Print method parameters
    qDebug() << "METHOD PARAMETERS";
    qDebug() << "  Iterations                                   : " << QString::fromStdString(rpi::VectorToString(registration->GetNumberOfIterations()));
    qDebug() << "  Minimum iterations                           : " << registration->GetMinimumNumberOfIterations();
    qDebug() << "  Maximum step length                          : " << registration->GetMaximumUpdateStepLength();
    qDebug() << "  Gradient type                                : " << registration->GetGradientType();
    qDebug() << "  Update field standard deviation              : " << registration->GetUpdateFieldStandardDeviation();
    qDebug() << "  Update field incompressibility               : " << registration->GetUpdateFieldIncompressibility();
    qDebug() << "  Update field kappa                           : " << registration->GetUpdateFieldKappa();
    qDebug() << "  Stationary velocity field standard deviation : " << registration->GetStationaryVelocityFieldStandardDeviation();
    qDebug() << "  Stationary velocity field incompressibility  : " << registration->GetStationaryVelocityFieldIncompressibility();
    qDebug() << "  Stationary velocity field kappa              : " << registration->GetStationaryVelocityFieldKappa();
    qDebug() << "  Use histogram matching?                      : " << QString::fromStdString(rpi::BooleanToString( registration->GetUseHistogramMatching()));
    qDebug() << "  Terms in BCH expansion                       : " << registration->GetNumberOfTermsBCHExpansion();
    qDebug() << "  Threshold stop values                        : " << QString::fromStdString(rpi::VectorToString<float>( registration->GetStopThreshold()));
    qDebug() << "  Spatial smoothing standard deviation         : " << registration->GetSpatialDerivativeStandardDeviation();
    qDebug() << "  Step size for Hessian-norm constraint        : " << registration->GetStepSize();
    qDebug() << "  DTI standard deviation                       : " << registration->GetDTIStandardDeviation();
    qDebug() << "  Noise estimator type                         : " << registration->GetNoiseEstimatorType();
    qDebug() << "  Noise estimator standard deviation           : " << registration->GetNoiseEstimatorStandardDeviation();
    qDebug() << "  Use Levenberg-Marquardt method?              : " << QString::fromStdString(rpi::BooleanToString( registration->GetNoiseEstimatorLM()));
    qDebug() << "  Noise estimator epsilon                      : " << registration->GetNoiseEstimatorEpsilon();
    

    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;

    typedef itk::ResampleImageFilter< MovingImageType,MovingImageType,TransformScalarType >    ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(registration->GetTransformation());
    resampler->SetInput((const MovingImageType*)proc->movingImage().GetPointer());
    resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );

    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << e.GetDescription();
        return 1;
    }

    itk::ImageBase<3>::Pointer result = resampler->GetOutput();
    qDebug() << "Resampled? ";
    result->DisconnectPipeline();


    if (proc->output())
      proc->output()->setData (result);
    return 0;

}

int itkProcessiLogDemonRegistration::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImage().IsNull())
        return 1;
    switch (imgType){
    //unfortunately incompressible log demons only work on float or double pixels...

    case itkProcessRegistration::UCHAR:
        return d->update<unsigned char>();
        break;
    case itkProcessRegistration::CHAR:
        return d->update<char>();
        break;
    case itkProcessRegistration::USHORT:
        return d->update<unsigned short>();
        break;
    case itkProcessRegistration::SHORT:
        return d->update<short>();
        break;
    case itkProcessRegistration::UINT:
       return d->update<unsigned int>();
       break;
    case itkProcessRegistration::INT:
        return d->update<int>();
        break;
    case itkProcessRegistration::ULONG:
       return d->update<unsigned long>();
       break;
    case itkProcessRegistration::LONG:
        return d->update<long>();
        break;
    case itkProcessRegistration::DOUBLE:
        return d->update<double>();
        break;
    default:
        return d->update<float>();
        break;
    }
}

bool itkProcessiLogDemonRegistration::writeTransform(const QString& file)
{

}
// /////////////////////////////////////////////////////////////////
// Process parameters
// /////////////////////////////////////////////////////////////////
void itkProcessiLogDemonRegistration::setNumberOfIterations(std::vector<unsigned int> iterations)
{
    d->iterations = iterations;
}
void itkProcessiLogDemonRegistration::setMinIterations(int minIterations)
{
    d->minIterations = minIterations ;
}
void itkProcessiLogDemonRegistration::setMaximumUpdateStepLength(float maximumUpdateStepLength)
{
    d->maximumUpdateStepLength =  maximumUpdateStepLength;
}
void itkProcessiLogDemonRegistration::setGradientType(unsigned int gradientType)
{
    d->gradientType = gradientType;
}
void itkProcessiLogDemonRegistration::setUpFieldSigma(float upFieldSigma)
{
    d->upFieldSigma = upFieldSigma;
}
void itkProcessiLogDemonRegistration::setUpFieldInc(unsigned int upFieldInc)
{
    d->upFieldInc = upFieldInc;
}
void itkProcessiLogDemonRegistration::setUpFieldKappa(float upFieldKappa)
{
    d->upFieldKappa = upFieldKappa;
}
void itkProcessiLogDemonRegistration::setVelFieldSigma(float velFieldSigma)
{
    d->velFieldSigma = velFieldSigma;
}
void itkProcessiLogDemonRegistration::setVelFieldInc(unsigned int velFieldInc)
{
    d->velFieldInc = velFieldInc;
}
void itkProcessiLogDemonRegistration::setVelFieldKappa(float velFieldKappa)
{
    d->velFieldKappa = velFieldKappa;
}
void itkProcessiLogDemonRegistration::setUseHistogramMatching(bool useHistogramMatching)
{
    d->useHistogramMatching = useHistogramMatching;
}
void itkProcessiLogDemonRegistration::setBCHExpansion(unsigned int BCHExpansion)
{
    d->BCHExpansion = BCHExpansion;
}
void itkProcessiLogDemonRegistration::setStop(std::vector<float> stop)
{
    d->stop = stop;
}
void itkProcessiLogDemonRegistration::setSpatialDerivativeSigma(float spatialDerivativeSigma)
{
    d->spatialDerivativeSigma = spatialDerivativeSigma;
}
void itkProcessiLogDemonRegistration::setStepSize(unsigned int stepSize)
{
    d->stepSize = stepSize;
}
void itkProcessiLogDemonRegistration::setDTIStandardDeviation(float DTIStandardDeviation)
{
    d->DTIStandardDeviation = DTIStandardDeviation;
}
void itkProcessiLogDemonRegistration::setNoiseEstimatorType(unsigned int noiseEstimatorType)
{
    d->noiseEstimatorType = noiseEstimatorType;
}
void itkProcessiLogDemonRegistration::setNoiseEstimatorSigma(float noiseEstimatorSigma)
{
    d->noiseEstimatorSigma = noiseEstimatorSigma;
}
void itkProcessiLogDemonRegistration::setNoiseEstimatorLM(bool noiseEstimatorLM)
{
    d->noiseEstimatorLM = noiseEstimatorLM;
}
void itkProcessiLogDemonRegistration::setNoiseEstimatorEpsilon(float noiseEstimatorEpsilon)
{
    d->noiseEstimatorEpsilon = noiseEstimatorEpsilon;
}
// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createItkProcessiLogDemonRegistration(void)
{
    return new itkProcessiLogDemonRegistration;
}
