// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#ifndef DIFFUSIONSEQUENCECOMPOSITEDATA_H
#define DIFFUSIONSEQUENCECOMPOSITEDATA_H

#include <dtkCore/dtkAbstractData.h>
#include <medCompositeDataSetsPluginExport.h>
#include <medCompositeDataSetsBase.h>
#include <itkGradientFileReader.h>

//class medDiffusionSequenceCompositeDataPrivate;

class medDiffusionSequenceCompositeDataToolBox;

class MEDCOMPOSITEDATASETSPLUGIN_EXPORT medDiffusionSequenceCompositeData: public MedInria::medCompositeDataSetsBase {

    typedef itk::GradientFileReader            GradientReaderType;
    typedef GradientReaderType::VectorType     GradientType;
    typedef GradientReaderType::VectorListType GradientListType;
    typedef QVector<dtkAbstractData*>          Volumes;

public:

    friend class medDiffusionSequenceCompositeDataToolBox;

    medDiffusionSequenceCompositeData(): MedInria::medCompositeDataSetsBase("DWI",this),version(0) { }
    virtual ~medDiffusionSequenceCompositeData() { }

    virtual QString description(void) const;

    virtual bool has_version(const unsigned num) const { return num==1; }

    virtual MedInria::medCompositeDataSetsBase* clone(const unsigned v) const {
        return new medDiffusionSequenceCompositeData(v);
    }

    static bool registered(void);

    virtual void read_description(const QByteArray& buf);

    //  Methods specific to this type.

    void readVolumes(QStringList);
    void setGradientList(const GradientListType& grads) { gradients = grads; }
    void setVolumeList(const Volumes& vols)             { images = vols;     }

private:

    medDiffusionSequenceCompositeData(const unsigned v): MedInria::medCompositeDataSetsBase("DWI",this), version(v) { }

    const unsigned   version;
    QStringList      image_list;
    Volumes          images;
    GradientListType gradients;
};

dtkAbstractData* createDiffusionSequenceCompositeData();

#endif
