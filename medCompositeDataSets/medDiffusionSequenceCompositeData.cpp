// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include <sstream>

#include <medDiffusionSequenceCompositeData.h>
#include <medDiffusionSequenceCompositeDataToolBox.h>
#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractDataReader.h>

#include <IOUtils.H>

// /////////////////////////////////////////////////////////////////
// medDiffusionSequenceCompositeData
// /////////////////////////////////////////////////////////////////

const medDiffusionSequenceCompositeData medDiffusionSequenceCompositeData::proto;
const char medDiffusionSequenceCompositeData::Tag[] = "DWI";

bool medDiffusionSequenceCompositeData::registered() const {
    return dtkAbstractDataFactory::instance()->registerDataType("medDiffusionSequenceCompositeData",createDiffusionSequenceCompositeData) &&
           medDiffusionSequenceCompositeDataToolBox::registered();
}

QString medDiffusionSequenceCompositeData::description() const {
    return "medDiffusionSequenceCompositeData";
}

bool medDiffusionSequenceCompositeData::read_description(const QByteArray& buf) {
    const std::string description(buf.data());
    std::istringstream iss(description);

    unsigned num;
    iss >> io_utils::skip_comments('#') >> io_utils::match("Images") >> num;
    for (unsigned i=0;i<num;++i) {
        std::string name;
        GradientType V;
        iss >> io_utils::skip_comments('#') >> io_utils::filename(name) >> io_utils::match('[') >> V[0] >> V[1] >> V[2] >> io_utils::match(']');
        gradients.push_back(V);
        image_list << QString(name.c_str());
    }

    return (iss.fail()) ? true : false;
}

bool medDiffusionSequenceCompositeData::write_description(QTextStream& out) {

    const bool named_images = image_list.size()==images.size();

    const unsigned num = images.size();
    out << "Images: " << num << '\n';
    for (unsigned i=0;i<num;++i) {
        const GradientType V = gradients[i];
        const QString im_name = (named_images) ? image_list[i] : QString("image")+QString::number(i);
        if (!named_images)
            image_list.push_back(im_name);
        out << im_name << " [" << V[0] << ' ' << V[1] << ' ' << V[2] << "]\n";
    }

    return true;
}

bool medDiffusionSequenceCompositeData::write_data(const QString& dirname,const dtkAbstractData* data) {
    return true;
}

void medDiffusionSequenceCompositeData::readVolumes(const QString& dirname,const QStringList& paths) {

    QList<QString> readers = dtkAbstractDataFactory::instance()->readers();
      
    for (int i=0;i<paths.size();++i) {
        QString filepath = dirname+"/"+paths[i];
        dtkAbstractDataReader* reader = NULL;
        for (int i=0;i<readers.size();++i) {
            reader = dtkAbstractDataFactory::instance()->reader(readers[i]);
            if (reader->canRead(filepath))
                break;
            else
                delete reader;
        }

        reader->read(filepath);
        dtkAbstractData* volume = reader->data();
        images.push_back(volume);
        delete reader;

        //  To be changed (and the push_back above might be moved after the checks).

        QString description = volume->description();
        if (!description.contains("Image")) {
            // emit medToolBoxCompositeDataSetImporter::showError(this,tr("file does not describe any known image type"),3000);
            continue;
        }
        if (description.contains ("Image4D")) {
            // emit medToolBoxCompositeDataSetImporter::showError(this,tr("4D image is not supported yet"),3000);
            continue;
        }
        if (!description.contains ("Image3D")) {
            // emit medToolBoxCompositeDataSetImporter::showError(this,tr("image should be 3D"),3000);
            continue;
        }
    }  
}

bool medDiffusionSequenceCompositeData::read_data(const QString& dirname) {
    readVolumes(dirname,image_list); // TODO: Error management....
    return true;
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractData* createDiffusionSequenceCompositeData()
{
    return new medDiffusionSequenceCompositeData;
}
