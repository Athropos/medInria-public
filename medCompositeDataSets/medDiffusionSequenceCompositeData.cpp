// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include <sstream>

#include <medMetaDataKeys.h>
#include <medDataReaderWriter.h>

#include <medDiffusionSequenceCompositeData.h>
#include <medDiffusionSequenceCompositeDataToolBox.h>
#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractDataReader.h>
#include <dtkCore/dtkAbstractDataWriter.h>

#include <IOUtils.H>

// /////////////////////////////////////////////////////////////////
// medDiffusionSequenceCompositeData
// /////////////////////////////////////////////////////////////////

const medDiffusionSequenceCompositeData medDiffusionSequenceCompositeData::proto;

const char medDiffusionSequenceCompositeData::ID[] = "medDiffusionSequenceCompositeData";
const char medDiffusionSequenceCompositeData::Tag[] = "DWI";
const char medDiffusionSequenceCompositeData::ImagesString[] = "Images:";
const char medDiffusionSequenceCompositeData::MetaDataString[] = "MetaData:";

bool medDiffusionSequenceCompositeData::registered() const {
    return dtkAbstractDataFactory::instance()->registerDataType(ID,create) &&
           medDiffusionSequenceCompositeDataToolBox::registered();
}

QString medDiffusionSequenceCompositeData::description() const {
    return "Composite dataset for diffusion sequence";
}

bool medDiffusionSequenceCompositeData::read_description(const QByteArray& buf) {
    const std::string description(buf.data());
    std::istringstream iss(description);

    unsigned num;
    iss >> io_utils::skip_comments('#') >> io_utils::match(ImagesString) >> num;

    //  Decode the index specifying which meta data to associate with the dataset.

    bool has_metadata;
    iss >> io_utils::match_optional(MetaDataString,has_metadata);
    if (has_metadata)
        iss >> meta_data_index;
    if (meta_data_index>=num)
        qWarning("medDiffusionSequence: invalid metadata index %d",meta_data_index);

    //  Read the gradient image names and the associated gradient.

    for (unsigned i=0;i<num;++i) {
        std::string name;
        GradientType V;
        iss >> io_utils::skip_comments('#') >> io_utils::filename(name) >> io_utils::match('[') >> V[0] >> V[1] >> V[2] >> io_utils::match(']');
        gradients.push_back(V);
        image_list << QString(name.c_str());
    }

    return (iss.fail()) ? true : false;
}

bool medDiffusionSequenceCompositeData::write_description(QTextStream& out) {

    if (image_list.size()!=images.size()) {
        qWarning("medDiffusionSequence: incoherent dataset %d!=%d",image_list.size(),images.size());
        return false;
    }

    const unsigned num = images.size();
    out << ImagesString << num << ' ' << MetaDataString << ' ' << meta_data_index << '\n';
    for (unsigned i=0;i<num;++i) {
        const GradientType V = gradients[i];
        const QString im_name = image_list[i];
        out << '"' << im_name << '"' << " [" << V[0] << ' ' << V[1] << ' ' << V[2] << "]\n";
    }

    return true;
}

bool medDiffusionSequenceCompositeData::write_data(const QString& dirname) {
    writeVolumes(dirname,image_list);
    return true;
}

dtkAbstractData* medDiffusionSequenceCompositeData::readVolume(const QString& path) {
    dtkAbstractData* volume = medInria::DataReaderWriter::read(path);
    const QString&   type   = volume->name();

    if (!type.contains("Image")) {
        // emit medToolBoxCompositeDataSetImporter::showError (this, tr ("file does not describe any known image type"), 3000);
        return 0;
    }

#if 0
    if (type.contains("Image4D")) {
        // emit medToolBoxCompositeDataSetImporter::showError (this, tr ("4D image is not supported yet"), 3000);
        return 0;
    }

    if (!type.contains("Image3D")) {
        // emit medToolBoxCompositeDataSetImporter::showError (this, tr ("image should be 3D"), 3000);
        return 0;
    }
#endif

    return volume;
}

void medDiffusionSequenceCompositeData::readVolumes(const QStringList& paths) {

    QList<QString> readers = dtkAbstractDataFactory::instance()->readers();
      
    for (int i=0;i<paths.size();++i) {
        const QString& filepath = paths[i];
        dtkAbstractData* volume = readVolume(filepath);
        images.push_back(volume);

        //  To be changed (and the push_back above might be moved after the checks).

        QString identifier = volume->identifier();
        if (!identifier.contains("Image")) {
            // emit medToolBoxCompositeDataSetImporter::showError(this,tr("file does not describe any known image type"),3000);
            continue;
        }
        if (identifier.contains ("Image4D")) {
            // emit medToolBoxCompositeDataSetImporter::showError(this,tr("4D image is not supported yet"),3000);
            continue;
        }
        if (!identifier.contains ("Image3D")) {
            // emit medToolBoxCompositeDataSetImporter::showError(this,tr("image should be 3D"),3000);
            continue;
        }
    }

    for (medMetaDataKeys::Key::Registery::const_iterator i=medMetaDataKeys::Key::all().begin();i!=medMetaDataKeys::Key::all().end();++i)
        if ((*i)->is_set_in(images[meta_data_index])) {
            (*i)->set(this,(*i)->getValues(images[meta_data_index]));
            qDebug() << "MetaData: " << (*i)->key() << (*i)->getValues(images[meta_data_index]);
        }
}

void medDiffusionSequenceCompositeData::readVolumes(const QString& dirname,const QStringList& paths) {
    QStringList filelist;
    for (int i=0;i<paths.size();++i) {
        const QString filepath = dirname+"/"+paths[i];
        filelist << filepath;
    }
    readVolumes(filelist);
}

void medDiffusionSequenceCompositeData::writeVolumes(const QString& dirname,const QStringList& paths) const {

    QList<QString> writers = dtkAbstractDataFactory::instance()->writers();
      
    for (int i=0;i<paths.size();++i) {
        QString filepath = dirname+"/"+paths[i];
        dtkAbstractDataWriter* writer = NULL;
        for (int j=0;j<writers.size();++j) {
            writer = dtkAbstractDataFactory::instance()->writer(writers[j]);
            if (writer->canWrite(filepath))
                break;
            else
                delete writer;
        }
        writer->setData(images[i]);
        writer->write(filepath);
        delete writer;
    }  
}

bool medDiffusionSequenceCompositeData::read_data(const QString& dirname) {
    readVolumes(dirname,image_list); // TODO: Error management....
    return true;
}
