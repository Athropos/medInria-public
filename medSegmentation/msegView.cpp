// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "msegView.h"

#include "msegController.h"
#include "msegAlgorithmConnectedThreshold.h"
#include "msegConfiguration.h"

#include "medAbstractViewScene.h"
#include <medCore/medAbstractView.h>

#include <dtkCore/dtkAbstractViewFactory.h>
#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkLog.h>

#include <QObject>
#include <QEvent>
#include <QGraphicsSceneMouseEvent>

namespace mseg {

// /////////////////////////////////////////////////////////////////
// medViewSegmentationPrivate
// /////////////////////////////////////////////////////////////////

class medViewSegmentationPrivate
{
public:
};

// /////////////////////////////////////////////////////////////////
// View
// /////////////////////////////////////////////////////////////////
QString View::s_description()
{
    static QString name = "medViewSegmentation";
    return name;
}

View::View(Controller * controller) 
    : dtkAbstractView(), 
    m_segmentationController(controller)
{
}

View::~View(void)
{
    removeFromAllViews();
}

QString View::description(void) const
{
    return s_description();
}

bool View::mousePressEvent( medAbstractViewScene * vscene, QGraphicsSceneMouseEvent *mouseEvent )
{
    return false;
}
bool View::mouseReleaseEvent( medAbstractViewScene * vscene, QGraphicsSceneMouseEvent *mouseEvent )
{
    return false;
}
bool View::mouseMoveEvent( medAbstractViewScene * vscene, QGraphicsSceneMouseEvent *mouseEvent )
{
    return false;
}


bool View::eventFilter( QObject *obj, QEvent *event )
{
    medAbstractViewScene * vscene = qobject_cast<medAbstractViewScene*>(obj);
    if ( !vscene ) {
        dtkWarning() << "mseg::View::eventFilter : Filtering events on unknown QObject";
        return false;
    }

    // Note : QEvent is not derived from QObject.
    // Using static_cast instead of dynamic_cast for speed of interaction.
    switch (event->type()) {
    case ( QEvent::GraphicsSceneMousePress) :
        {
            QGraphicsSceneMouseEvent* mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);
            return this->mousePressEvent( vscene, mouseEvent );
        }
    case ( QEvent::GraphicsSceneMouseMove) :
        {
            QGraphicsSceneMouseEvent* mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);
            return this->mouseMoveEvent( vscene, mouseEvent );
        }
    case ( QEvent::GraphicsSceneMouseRelease ) :
        {
            QGraphicsSceneMouseEvent* mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);
            return this->mouseReleaseEvent( vscene, mouseEvent );
        }
    default:
        {
            // standard event processing
            return QObject::eventFilter(obj, event);
        }
    }
}

void View::installOnView( medAbstractView * view )
{
    if (m_views.contains(view)) {
        dtkWarning() << "Installing View when it has already been installed";
        return;
    }

    m_views.insert(view);
    medAbstractViewScene * scene = Controller::viewScene( view );
    scene->installEventFilter( this );
}

void View::removeFromView(medAbstractView * view)
{
    if ( m_views.contains(view)) {
        medAbstractViewScene * scene = Controller::viewScene( view );
        scene->removeEventFilter( this );
        m_views.remove(view);
    }
}

void View::removeFromAllViews()
{
    foreach(medAbstractView * view, m_views) {
        medAbstractViewScene * scene = Controller::viewScene( view );
        scene->removeEventFilter( this );
    }
    m_views.clear();
}


medAbstractViewScene * View::scene(medAbstractView * view)
{
    return Controller::viewScene( view );;
}


} // namespace mseg


