// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "msegViewFilter.h"

#include "msegAlgorithmConnectedThreshold.h"

#include "medAbstractViewScene.h"
#include <medAbstractView.h>
#include <medToolBoxSegmentation.h>

#include <dtkCore/dtkAbstractViewFactory.h>
#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkLog.h>

#include <QObject>
#include <QEvent>
#include <QGraphicsSceneMouseEvent>

namespace mseg {

// /////////////////////////////////////////////////////////////////
// medViewSegmentationPrivate
// /////////////////////////////////////////////////////////////////

class medViewSegmentationPrivate
{
public:
};

// /////////////////////////////////////////////////////////////////
// View
// /////////////////////////////////////////////////////////////////
QString ViewFilter::s_description()
{
    static QString name = "medViewSegmentation";
    return name;
}

ViewFilter::ViewFilter(medToolBoxSegmentation * controller) 
    : dtkAbstractView(), 
    m_segmentationController(controller)
{
}

ViewFilter::~ViewFilter(void)
{
    removeFromAllViews();
}

QString ViewFilter::description(void) const
{
    return s_description();
}

bool ViewFilter::mousePressEvent( medAbstractViewScene * vscene, QGraphicsSceneMouseEvent *mouseEvent )
{
    return false;
}
bool ViewFilter::mouseReleaseEvent( medAbstractViewScene * vscene, QGraphicsSceneMouseEvent *mouseEvent )
{
    return false;
}
bool ViewFilter::mouseMoveEvent( medAbstractViewScene * vscene, QGraphicsSceneMouseEvent *mouseEvent )
{
    return false;
}


bool ViewFilter::eventFilter( QObject *obj, QEvent *event )
{
    medAbstractViewScene * vscene = qobject_cast<medAbstractViewScene*>(obj);
    if ( !vscene ) {
        dtkWarning() << "mseg::View::eventFilter : Filtering events on unknown QObject";
        return false;
    }

    // Note : QEvent is not derived from QObject.
    // Using static_cast instead of dynamic_cast for speed of interaction.
    switch (event->type()) {
    case ( QEvent::GraphicsSceneMousePress) :
        {
            QGraphicsSceneMouseEvent* mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);
            return this->mousePressEvent( vscene, mouseEvent );
        }
    case ( QEvent::GraphicsSceneMouseMove) :
        {
            QGraphicsSceneMouseEvent* mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);
            return this->mouseMoveEvent( vscene, mouseEvent );
        }
    case ( QEvent::GraphicsSceneMouseRelease ) :
        {
            QGraphicsSceneMouseEvent* mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);
            return this->mouseReleaseEvent( vscene, mouseEvent );
        }
    default:
        {
            // standard event processing
            return QObject::eventFilter(obj, event);
        }
    }
}

void ViewFilter::installOnView( medAbstractView * view )
{
    if (m_views.contains(view)) {
        dtkWarning() << "Installing View when it has already been installed";
        return;
    }

    m_views.insert(view);
    medAbstractViewScene * scene = medToolBoxSegmentation::viewScene( view );
    scene->installEventFilter( this );
}

void ViewFilter::removeFromView(medAbstractView * view)
{
    if ( m_views.contains(view)) {
        medAbstractViewScene * scene = medToolBoxSegmentation::viewScene( view );
        scene->removeEventFilter( this );
        m_views.remove(view);
    }
}

void ViewFilter::removeFromAllViews()
{
    foreach(medAbstractView * view, m_views) {
        medAbstractViewScene * scene = medToolBoxSegmentation::viewScene( view );
        scene->removeEventFilter( this );
    }
    m_views.clear();
}


medAbstractViewScene * ViewFilter::scene(medAbstractView * view)
{
    return medToolBoxSegmentation::viewScene( view );;
}


} // namespace mseg


