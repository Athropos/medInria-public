// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "medSegmentationConfiguration.h"

#include "medToolBoxSegmentationView.h"

#include "msegAlgorithmConnectedThreshold.h"

#include "medAbstractViewScene.h"

#include <medCore/medAbstractView.h>
#include <medCore/medRunnableProcess.h>
#include <medCore/medJobManager.h>

#include <medGui/medStackedViewContainers.h>
#include <medGui/medProgressionStack.h>
#include <medGui/medViewerConfigurationFactory.h>
#include <medGui/medViewContainer.h>
#include <medGui/medViewerToolBoxView.h>

#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkLog.h>

class EventInterceptor : public QGraphicsObject {
public:
    EventInterceptor( medSegmentationConfiguration * config ) 
        :  m_segmentationConfig (config)
    {
// By default accepts all mouse buttons
        this->setAcceptedMouseButtons(Qt::LeftButton);
    }
    // from QGraphicsItem
    bool contains ( const QPointF & point ) const { return true; }

    // Implement QGraphicsItem
    QRectF boundingRect() const { return this->scene()->sceneRect(); }
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0) 
    {
        return;
    }

    void mousePressEvent ( QGraphicsSceneMouseEvent * mouseEvent );
    void mouseReleaseEvent ( QGraphicsSceneMouseEvent * mouseEvent );

private:
    medSegmentationConfiguration * m_segmentationConfig;
};

void EventInterceptor::mousePressEvent( QGraphicsSceneMouseEvent * mouseEvent )
{
    m_segmentationConfig->mousePressEvent( mouseEvent );
}

void EventInterceptor::mouseReleaseEvent( QGraphicsSceneMouseEvent * mouseEvent )
{
    m_segmentationConfig->mouseReleaseEvent( mouseEvent );
}

// /////////////////////////////////////////////////////////////////
// medSegmentationConfigurationPrivate
// /////////////////////////////////////////////////////////////////
class medSegmentationConfigurationPrivate
{
public:
    medViewerToolBoxView                *viewToolBox;
    medToolBoxSegmentationView          *segmentationToolBox;

    static medAbstractViewScene * viewScene( dtkAbstractView * view );
    static dtkAbstractData * viewData( dtkAbstractView * view );

    QScopedPointer< EventInterceptor > viewEventHandler;
};


medAbstractViewScene * medSegmentationConfigurationPrivate::viewScene( dtkAbstractView * view )
{
    medAbstractView * mview = qobject_cast< medAbstractView * >( view );
    if ( ! mview ) {
        dtkLog::debug() << "Failed to get a view";
        return NULL;
    }

    QGraphicsView * qview = qobject_cast < QGraphicsView * >( mview->receiverWidget() );
    medAbstractViewScene * ret  = qobject_cast < medAbstractViewScene * >( qview->scene() );
    return ret;
}

dtkAbstractData * medSegmentationConfigurationPrivate::viewData( dtkAbstractView * view )
{
    medAbstractView * mview = qobject_cast< medAbstractView * >( view );
    if ( ! mview ) {
        dtkLog::debug() << "Failed to get a view";
        return NULL;
    }

    // Why isn't the data of an abstract view a dtkAbstractData????
    return reinterpret_cast< dtkAbstractData * >( mview->data() );
}


// /////////////////////////////////////////////////////////////////
// medSegmentationConfiguration
// /////////////////////////////////////////////////////////////////
//static
medViewerConfiguration * medSegmentationConfiguration::createMedSegmentationConfiguration()
{
    return new medSegmentationConfiguration;
}

medSegmentationConfiguration::medSegmentationConfiguration(QWidget * parent /* = NULL */ ) : 
medViewerConfiguration(parent), d(new medSegmentationConfigurationPrivate)
{
    d->segmentationToolBox = new medToolBoxSegmentationView( parent );
    d->viewEventHandler.reset( new EventInterceptor(this) );

    this->addToolBox( d->segmentationToolBox );

}

medSegmentationConfiguration::~medSegmentationConfiguration(void)
{
    delete d;
    d = NULL;
}

bool medSegmentationConfiguration::registerWithViewerConfigurationFactory()
{
    return medViewerConfigurationFactory::instance()->registerConfiguration( 
        medSegmentationConfiguration::ConfigurationName(), 
        medSegmentationConfiguration::createMedSegmentationConfiguration
        );
}

QString medSegmentationConfiguration::ConfigurationName()
{
    // This is the string that appears in the drop-down.
    static QString confName( tr("Segmentation") );
    return confName;
}

void medSegmentationConfiguration::setupViewContainerStack()
{
    if (!stackedViewContainers()->count())
    {
        //Containers:
        addSingleContainer();
        // addMultiContainer();
        // addCustomContainer();
        connect(stackedViewContainers()->container("Single"),SIGNAL(viewAdded(dtkAbstractView*)),
            this,SLOT(onViewAdded(dtkAbstractView*)));
        connect( d->segmentationToolBox, SIGNAL( addSeedPointPressed()), this, SLOT( beginAddSeedPoint() ) );
    }
}

//static
QString medSegmentationConfiguration::description( void ) const
{
    static QString descString( "medSegmentationConfiguration" );
    return descString;
}

void medSegmentationConfiguration::onViewAdded( dtkAbstractView* view )
{

}

void medSegmentationConfiguration::beginAddSeedPoint()
{
    dtkAbstractView * view = stackedViewContainers()->container("Single")->view() ;
    medAbstractViewScene * scene = medSegmentationConfigurationPrivate::viewScene( view );

    if ( !scene ) 
        return;

    scene->addItem( d->viewEventHandler.data() );
}

void medSegmentationConfiguration::mousePressEvent( QGraphicsSceneMouseEvent * mouseEvent )
{
    dtkAbstractView * view = stackedViewContainers()->container("Single")->view() ;
    medAbstractViewScene * scene = medSegmentationConfigurationPrivate::viewScene( view );
    dtkAbstractData * viewData = medSegmentationConfigurationPrivate::viewData( view );

    mouseEvent->accept();

    if (scene->isScene2D()) {
        // Convert mouse click to a 3D point in the image.

        QVector3D posImage = scene->sceneToImagePos( mouseEvent->pos() );
        //Project vector onto plane


        dtkSmartPointer <mseg::AlgorithmConnectedThreshold> alg( new mseg::AlgorithmConnectedThreshold() );

        alg->setInput(viewData);
        alg->setSeedPoint( posImage );

        QScopedPointer<medRunnableProcess> runProcess (new medRunnableProcess) ;

        runProcess->setProcess (alg);

        d->segmentationToolBox->progressionStack()->addJobItem(runProcess.data(), "Progress:");

        connect (runProcess.data(), SIGNAL (success  (QObject*)),  this, SIGNAL (success (QObject*)));
        connect (runProcess.data(), SIGNAL (failure  (QObject*)),  this, SIGNAL (failure (QObject*)));
        connect (runProcess.data(), SIGNAL (cancelled (QObject*)), this, SIGNAL (cancelled (QObject*)));

        medJobManager::instance()->registerJobItem(runProcess.data(), tr("Segmenting"));
        QThreadPool::globalInstance()->start(dynamic_cast<QRunnable*>(runProcess.take()));

//        alg->update();

#pragma message DTK_COMPILER_WARNING("JDS : Need to complete this")
        /*
    Create a segmentation algorithm, pass it the data and 
        run it. 
        gather the output.
        register the output in the non-persistent db
        Add the output as a layer to the view
        */
        
        dtkSmartPointer<dtkAbstractData> outputData = alg->output();
//        medDatabaseCon
    }
}

void medSegmentationConfiguration::mouseReleaseEvent( QGraphicsSceneMouseEvent * mouseEvent )
{
    medAbstractViewScene * scene = medSegmentationConfigurationPrivate::viewScene( stackedViewContainers()->container("Single")->view() );
    scene->removeItem( d->viewEventHandler.data() );
    mouseEvent->accept();
}

void medSegmentationConfiguration::success( QObject * sender )
{

}

void medSegmentationConfiguration::failure( QObject * sender )
{

}

void medSegmentationConfiguration::cancelled( QObject * sender )
{

}










